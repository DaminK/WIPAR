configfile: "config/config.yaml"

ruleorder: pipeline_entry > parcellation > feature_calculation > feature_elimination


from itertools import product as iterproduct
def create_parameter_product( conf ):
	features	= {}
	for feat, params in conf.items():
		if params is None:
			features[feat] = {}
		else:
			# create a pattern of form "featurename_{}_{}_...", with # of params replacement fields
			pattern = "_".join( [f"{feat}"] +  ["{}"]*len(params) )
			# insert parameter names and parameter name replacement fields into pattern
			pattern = pattern.format(*map( "{0}~{{{0}}}".format, params.keys() ))
			# create cartesian product over all parameter values
			values = iterproduct( *params.values() )
			# create list parameter dictionaries from cartesian product
			values = [ dict(zip(params.keys(), vals)) for vals in values]
			for vals in values:
				features[ pattern.format(**vals) ] = vals
	return features

mouses 		= config["branch_opts"]["mouses"]
dates		= config["branch_opts"]["dates"]
parcellations	= config["branch_opts"]["parcellations"]
filters		= config["branch_opts"]["filters"]

conditions	= config["branch_opts"]["conditions"]
if conditions is None:
	# if no conditions are given, create cartesian product of all sides and modalities
	sides			= config["trial_conditions"]["sides"]["conds"]
	modalities		= config["trial_conditions"]["modalities"]["conds"]

	trial_conditions	= { f"{side}_{modal}" : {"modality" : m, "target_side_left" : s}
					for side,s in sides.items() for modal,m in modalities.items()}
	phase_condition		= config["phase_conditions"]
	phase_conditions	= dict.fromkeys(trial_conditions.keys(), phase_condition["stimulus"] )
	print(phase_conditions)
else:
	# create trial_conditions fitting for trial data by resolving column names and conditions from trial_conditions
	trial_condition		= config["trial_conditions"]
	trial_conditions	= { label :
					{ trial_condition[condition]["column"] : trial_condition[condition]["conds"][key]
						for condition, key in conds.items() if condition != "phase" }
					for label, conds in conditions.items() }
	# lookup specified phases in phase_conditions
	phase_condition		= config["phase_conditions"]
	phase_conditions	= { label : phase_condition[conds["phase"]] if "phase" in conds else None
					for label, conds in conditions.items() }

feature_conf	= config["branch_opts"]["features"]
features	= create_parameter_product( feature_conf )

rfe_ns		= config["branch_opts"]["rfe"]["selected_features_n"]

decoder_conf	= config["branch_opts"]["decoders"]
decoders	= create_parameter_product( decoder_conf )

wildcard_constraints:
	mouse		= r"[a-zA-Z\d_]+",
	parcellation	= r"[a-zA-Z\d_]+",
	filter		= r"[a-zA-Z\d_]+",
	cond		= r"[a-zA-Z\d_]+",
	feature		= r"[a-zA-Z\d_~.\[\], ]+",
	decoder		= r"[a-zA-Z\d_~.]+",



###   Output accumulation rules   ###

# The first rule is default
rule all:
	input:
		[ f"results/{mouse}/{parcellation}/{filter}/decoder/{'.'.join(trial_conditions)}/performances.png"
			for mouse in mouses
			for parcellation in parcellations
		  	for filter in filters],
		[ f"results/{mouse}/{parcellation}/{filter}/decoder/{'.'.join(trial_conditions)}/{feature}/plots/performance.png"
			for mouse in mouses
		   	for parcellation in parcellations
		   	for filter in filters
		   	for cond in trial_conditions
		   	for feature in features],
rule all_plots:
	input:
		 [ f"results/{mouse}/{parcellation}/{filter}/decoder/{'.'.join(trial_conditions)}/{feature}/plots/performance.png"
			   for mouse in mouses
			   for parcellation in parcellations
			   for filter in filters
			   for cond in trial_conditions
			   for feature in features]

rule all_decode:
	input:
		[ f"results/{mouse}/{parcellation}/{filter}/decoder/{'.'.join(trial_conditions)}/{feature}/{decoder}/decoder_model.pkl"
				for mouse in mouses
				for parcellation in parcellations
				for filter in filters
				for feature in features
				for decoder in decoders]

rule all_features:
	input:
		[ f"results/{mouse}/{parcellation}/{filter}/{cond}/{feature}/feature_data.h5"
				for mouse in mouses
				for parcellation in parcellations
				for filter in filters
				for cond in trial_conditions
				for feature in features ]

rule all_rfe:
	input:
		 [ f"results/{mouse}/{parcellation}/{filter}/rfe/{'.'.join(trial_conditions)}/{rfe_n}/{feature}/circle_plot.png"
		   for mouse in mouses
		   for parcellation in parcellations
		   for filter in filters
		   for feature in features
		   for rfe_n in rfe_ns]



###   Data processing   ###

rule pipeline_entry:
	input:
		tasks	= [ f"resources/experiment/{{mouse}}/{date}/task_data/"
				for date in dates ],
		Vc	= [ f"resources/experiment/{{mouse}}/{date}/SVD_data/Vc.mat"
				for date in dates ],
		trans_params = [ f"resources/experiment/{{mouse}}/{date}/SVD_data/opts.mat"
				  for date in dates ],
	output:
		"results/{mouse}/SVD/data.h5",
		config = "results/{mouse}/SVD/conf.yaml",
	log:
		"results/{mouse}/SVD/pipeline_entry.log"
	conda:
		"envs/environment.yaml"
	resources:
		memb_mb=1000
	script:
		"scripts/default_entry.py"

def parcellation_input(wildcards):
	input = {
		"data"	: "results/{mouse}/SVD/data.h5",
		"config": "results/{mouse}/SVD/conf.yaml" }
	input["meta"]	= config["parcellation_opts"]["paths"][wildcards["parcellation"]]
	return input

rule parcellation:
	input:
		unpack(parcellation_input)
	output:
		"results/{mouse}/{parcellation}/data.h5",
		config = "results/{mouse}/{parcellation}/conf.yaml",
	wildcard_constraints:
		parcellation = "(?!SVD).+"
	log:
		"results/{mouse}/{parcellation}/parcellation.log"
	conda:
		"envs/environment.yaml"
	script:
		"scripts/parcellation.py"

rule prefilters:
	input:
		"results/{mouse}/{parcellation}/data.h5",
		config = "results/{mouse}/{parcellation}/conf.yaml",
	output:
		"results/{mouse}/{parcellation}/{filter}/filtered_data.h5",
		config = "results/{mouse}/{parcellation}/{filter}/conf.yaml",
	log:
		"results/{mouse}/{parcellation}/{filter}/prefilters.log"
	conda:
		"envs/environment.yaml"
	resources:
		memb_mb=1000
	script:
		"scripts/prefilter.py"

def condition_params(wildcards):
	params = {
		"trial_conditions" : { wildcards["cond"] : trial_conditions[wildcards["cond"]]},
		"phase_conditions" : { wildcards["cond"] : phase_conditions[wildcards["cond"]]},
	}
	return params

rule condition:
	input:
		"results/{mouse}/{parcellation}/{filter}/filtered_data.h5",
		config = "results/{mouse}/{parcellation}/{filter}/conf.yaml",
	output:
		"results/{mouse}/{parcellation}/{filter}/{cond}/conditional_data.h5",
		config = "results/{mouse}/{parcellation}/{filter}/{cond}/conf.yaml",
	params:
		condition_params
	log:
		"results/{mouse}/{parcellation}/{filter}/{cond}/conditionals.log"
	conda:
		"envs/environment.yaml"
	resources:
		memb_mb=1000
	script:
		"scripts/conditional.py"

rule feature_calculation:
	input:
		"results/{mouse}/{parcellation}/{filter}/{cond}/conditional_data.h5",
		config = "results/{mouse}/{parcellation}/{filter}/{cond}/conf.yaml",
	output:
		"results/{mouse}/{parcellation}/{filter}/{cond}/{feature}/feature_data.h5",
		config = "results/{mouse}/{parcellation}/{filter}/{cond}/{feature}/conf.yaml",
	params:
		params = lambda wildcards: features[wildcards["feature"]]
	log:
		"results/{mouse}/{parcellation}/{filter}/{cond}/{feature}/feature_calculation.log"
	conda:
		"envs/environment.yaml"
	resources:
		memb_mb=4000
	script:
		"scripts/feature.py"

rule feature_elimination:
	input:
		feats = [f"results/{{mouse}}/{{parcellation}}/{{filter}}/{cond}/{{feature}}/feature_data.h5" for cond in trial_conditions],
		labels = "results/{mouse}/{parcellation}/data.h5",
		#config = "results/{mouse}/{parcellation}/{filter}/{cond}/{feature}/conf.yaml",
	output:
		best_feats = f"results/{{mouse}}/{{parcellation}}/{{filter}}/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/best_feats.pkl",
		model = f"results/{{mouse}}/{{parcellation}}/{{filter}}/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/decoder_model.pkl",
		perf = f"results/{{mouse}}/{{parcellation}}/{{filter}}/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/decoder_perf.pkl",
		config = f"results/{{mouse}}/{{parcellation}}/{{filter}}/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/conf.yaml",
		plot = f"results/{{mouse}}/{{parcellation}}/{{filter}}/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/circle_plot.png",
	params:
		conds = list(trial_conditions),
		reps = 5, #used to be k_folds but was removed form config
	log:
	   f"results/{{mouse}}/{{parcellation}}/{{filter}}/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/feature_calculation.log"
	conda:
		 "envs/environment.yaml"
	resources:
		memb_mb=1000
	script:
		  "scripts/recursive_feature_elimination.py"

rule decoding:
	input:
		[f"results/{{mouse}}/{{parcellation}}/{{filter}}/{cond}/{{feature}}/feature_data.h5" for cond in trial_conditions],
	output:
		f"results/{{mouse}}/{{parcellation}}/{{filter}}/decoder/{'.'.join(trial_conditions)}/{{feature}}/{{decoder}}/decoder_model.pkl",
		f"results/{{mouse}}/{{parcellation}}/{{filter}}/decoder/{'.'.join(trial_conditions)}/{{feature}}/{{decoder}}/decoder_perf.pkl",
		config = f"results/{{mouse}}/{{parcellation}}/{{filter}}/decoder/{{feature}}/{{decoder}}/{'.'.join(trial_conditions)}/conf.yaml",
	params:
		conds = list(trial_conditions),
		params = lambda wildcards: decoders[wildcards["decoder"]]
	log:
	   f"results/{{mouse}}/{{parcellation}}/{{filter}}/decoder/{'.'.join(trial_conditions)}/{{feature}}/{{decoder}}/decoding.log",
	conda:
		"envs/environment.yaml"
	resources:
		memb_mb=4000
	script:
		"scripts/decoding.py"



###   Plotting   ###

rule plot_performance:
	input:
		[f"results/{{mouse}}/{{parcellation}}/{{filter}}/decoder/{'.'.join(trial_conditions)}/{{feature}}/{decoder}/decoder_perf.pkl" for decoder in decoders],
	output:
		f"results/{{mouse}}/{{parcellation}}/{{filter}}/decoder/{'.'.join(trial_conditions)}/{{feature}}/plots/performance.png",
		f"results/{{mouse}}/{{parcellation}}/{{filter}}/decoder/{'.'.join(trial_conditions)}/{{feature}}/plots/performance.pkl",
	params:
		conds=list(trial_conditions),
		decoders=decoders,
	log:
		f"results/{{mouse}}/{{parcellation}}/{{filter}}/decoder/{'.'.join(trial_conditions)}/{{feature}}/plots/plot_performance.log",
	conda:
		 "envs/environment.yaml"
	script:
		  "scripts/plot_performance.py"

rule plot_performances:
	input:
		[f"results/{{mouse}}/{{parcellation}}/{{filter}}/decoder/{'.'.join(trial_conditions)}/{feature}/{decoder}/decoder_perf.pkl"
				for feature in features
				for decoder in decoders],
	output:
		  f"results/{{mouse}}/{{parcellation}}/{{filter}}/decoder/{'.'.join(trial_conditions)}/performances.png",
	params:
		conds=list(trial_conditions),
		decoders=decoders,
		features=features,
	log:
		f"results/{{mouse}}/{{parcellation}}/{{filter}}/decoder/{'.'.join(trial_conditions)}/plot_performances.log",
	conda:
		 "envs/environment.yaml"
	script:
		  "scripts/plot_performances.py"



rule debug:
	input:
		tasks	= [ f"resources/experiment/{mouse}/{date}/task_data/"
				for date in dates for mouse in mouses ],
	conda:
		"envs/environment.yaml"
	log:
		"results/debug.log"
	script:
		"scripts/debug_snakemake.py"



###   legacy tests   ###

rule test_data:
	input:
		 "results/GN06/SVD/data.h5"
	log:
	   "results/GN06/SVD/test_data.log"
	conda:
		 "envs/environment.yaml"
	script:
		  "code/test_data.py"

rule test_analysis:
	input:
		 "results/GN06/SVD/data.h5"
	log:
	   "results/GN06/SVD/test_analysis.log"
	conda:
		 "envs/environment.yaml"
	script:
		  "code/test_analysis.py"
