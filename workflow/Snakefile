configfile: "config/config.yaml"

ruleorder: pipeline_entry > locaNMF > parcellation > feature_calculation > feature_elimination


from itertools import product as iterproduct
def create_parameters( branch_conf, static_conf={} ):
	'''
	creates dictionary of unique names (used in paths) and corresponding parameters to be passed by snakemake
	'''
	default_params	= branch_conf["default"] if "default" in branch_conf else {}
	parameters	= {}
	for branch, br_params in branch_conf.items():
		if branch == "default":
			continue
		if br_params is None:
			br_params = {}
		# combine br_params with defaults into total params
		params = default_params | br_params
		# create a pattern of form "branchname_{}_{}_...", with # of params replacement fields
		pattern	= "_".join( [f"{branch}"] +  ["{}"]*len(params) )
		# insert parameter names and parameter name replacement fields into pattern
		pattern	= pattern.format(*map( "{0}~{{{0}}}".format, params.keys() ))
		# create cartesian product over all parameter values
		values	= iterproduct( *params.values() )
		# create list parameter dictionaries from cartesian product
		values	= [ dict(zip(params.keys(), vals)) for vals in values]
		# include static parametrs if present
		if branch in static_conf and static_conf[branch] is not None:
			values = [ static_conf[branch] | vals for vals in values ]
		for vals in values:
			parameters[ pattern.format(**vals) ] = {"branch" : branch} | vals
	return parameters


mouses 		= config["branch_opts"]["mouses"]
#dates		= config["branch_opts"]["dates"]
#mouse_dates = []

mouse_dates = ["_".join([mouse_id,date]) for mouse_id,dates in mouses.items() for date in dates ]

parcells_conf	= config["branch_opts"]["parcellations"]
parcells_static	= config["static_params"]["parcellations"]
parcellations	= create_parameters( parcells_conf, parcells_static )
trial_filters	= config["branch_opts"]["selected_trials"]

conditions	= config["branch_opts"]["conditions"]
if conditions is None:
	# if no conditions are given, create cartesian product of all sides and modalities
	sides			= config["trial_conditions"]["sides"]["conds"]
	modalities		= config["trial_conditions"]["modalities"]["conds"]

	trial_conditions	= { f"{side}_{modal}" : {"modality" : m, "target_side_left" : s}
					for side,s in sides.items() for modal,m in modalities.items()}
	phase_condition		= config["phase_conditions"]
	phase_conditions	= dict.fromkeys(trial_conditions.keys(), phase_condition["stimulus"] )
else:
	defaults		= conditions["default"] if "default" in conditions else {}

	# create trial_conditions fitting for trial data by resolving column names and conditions from trial_conditions
	trial_condition		= config["trial_conditions"]
	trial_conditions	= { label :
								{
										trial_condition[condition]["column"] : [trial_condition[condition]["conds"][vals] for vals in value] if isinstance(value,list) else trial_condition[condition]["conds"][value]
								for condition, value in (defaults | conds).items() if condition != "phase"}
							for label, conds in conditions.items() if label != "default" }


	# lookup specified phases in phase_conditions
	phase_condition		= config["phase_conditions"]
	phase_conditions	= { label : phase_condition[(defaults | conds)["phase"]] if "phase" in (defaults | conds) else None
					for label, conds in conditions.items() if label != "default" }

feature_conf	= config["branch_opts"]["features"]
feature_static	= config["static_params"]["features"]
features	= create_parameters( feature_conf, feature_static )

rfe_ns		= config["branch_opts"]["rfe"]["selected_features_n"]

decoder_conf	= config["branch_opts"]["decoders"]
decoder_static	= config["static_params"]["decoders"]
decoders	= create_parameters( decoder_conf, decoder_static )

wildcard_constraints:
	mouse_dates	= r"[a-zA-Z\d_-]+",
	parcellation	= r"[a-zA-Z\d_~.]+",
	filter		= r"[a-zA-Z\d_~.]+",
	cond		= r"[a-zA-Z\d_]+",
	feature		= r"[a-zA-Z\d_~.\[\], ]+",
	decoder		= r"[a-zA-Z\d_~.]+",



###   Output accumulation rules   ###

# The first rule is default
rule decoding_performances:
	input:
		[ f"results/{'_'.join(mouse_dates)}/{parcellation}/{filter}/Decoding/decoder/{'.'.join(trial_conditions)}/performances.png"
			for parcellation in parcellations
		  	for filter in trial_filters],
		[ f"results/{'_'.join(mouse_dates)}/{parcellation}/{filter}/Decoding/decoder/{'.'.join(trial_conditions)}/{feature}/plots/performance.png"
		   	for parcellation in parcellations
		   	for filter in trial_filters
		   	for cond in trial_conditions
		   	for feature in features],


rule all_decode:
	input:
		[ f"results/{'_'.join(mouse_dates)}/{parcellation}/{filter}/Decoding/decoder/{'.'.join(trial_conditions)}/{feature}/{decoder}/decoder_model.pkl"
				for parcellation in parcellations
				for filter in trial_filters
				for feature in features
				for decoder in decoders]

rule all_features:
	input:
		[ f"results/{'_'.join(mouse_dates)}/{parcellation}/{filter}/Features/{cond}/{feature}/feature_data.h5"
				for parcellation in parcellations
				for filter in trial_filters
				for cond in trial_conditions
				for feature in features ]

rule best_features:
	input:
		 [ f"results/{'_'.join(mouse_dates)}/{parcellation}/{filter}/Decoding/rfe/{'.'.join(trial_conditions)}/{rfe_n}/{feature}/circle_plot.png"
		   for parcellation in parcellations
		   for filter in trial_filters
		   for feature in features
		   for rfe_n in rfe_ns]



###   Data processing   ###

rule pipeline_entry:
	'''
	aggregates all task and svd data from one session with one animal
	'''
	input:
		_	= [[ f"resources/experiment/{mouse_id}/{date}/task_data/"
					 for date in dates] for mouse_id,dates in mouses.items()], #To make sure that files are present, unfortunatly gets flattened -> losing information which dates belong to which mouse
		Vc	= [ f"resources/experiment/{mouse_id}/{date}/SVD_data/Vc.mat"
				  for mouse_id,dates in mouses.items() for date in dates],
		trans_params = [ f"resources/experiment/{mouse_id}/{date}/SVD_data/opts.mat"
						 for mouse_id,dates in mouses.items() for date in dates],
	output:
		"results/{mouse_dates}/SVD/data.h5",
		config = "results/{mouse_dates}/SVD/conf.yaml",
	params:
		mouse_dates_str = '_'.join(mouse_dates),
		#maybe find a clean solution from flattened array,
		task_structured = {mouse_id: [ f"resources/experiment/{mouse_id}/{date}/task_data/"
				  for date in dates] for mouse_id,dates in mouses.items()} # so we are using this one and we can actually use a dict to make it even comfier
	log:
		"results/{mouse_dates}/SVD/pipeline_entry.log"
	conda:
		"envs/environment.yaml"
	resources:
		memb_mb=1000
	script:
		"scripts/default_entry.py"

def parcellation_input(wildcards):
	input = {
		"data"	: "results/{mouse_dates}/SVD/data.h5",
		"config": "results/{mouse_dates}/SVD/conf.yaml" }
	#if wildcards["parcellations"] in config["paths"]["parcellations"].keys(): #<- leads to such a weird error
	branch = parcellations[wildcards["parcellation"]]["branch"]
	input.update( config["paths"]["parcellations"][branch] )
	return input

rule parcellation:
	'''
	decomposes data into different parcellations
	'''
	input:
		unpack(parcellation_input)
	params:
		params = lambda wildcards: parcellations[wildcards["parcellation"]]
	output:
		"results/{mouse_dates}/{parcellation}/data.h5",
		config = "results/{mouse_dates}/{parcellation}/conf.yaml",
	wildcard_constraints:
		# exclude SVD as parcellation
		parcellation = "(?!SVD).+"
	log:
		"results/{mouse_dates}/{parcellation}/parcellation.log"
	conda:
		#"envs/environment.yaml"	# TODO: fix this!!
		"envs/locaNMF_environment.yaml"
	script:
		"scripts/parcellation.py"

use rule parcellation as locaNMF with:
	threads:
		workflow.cores*0.75
	wildcard_constraints:
		parcellation = "LocaNMF"
	conda:
		"envs/locaNMF_environment.yaml"

rule trial_selection:
	'''
	can select trials through predefined filters
	'''
	input:
		"results/{mouse_dates}/{parcellation}/data.h5",
		config = "results/{mouse_dates}/{parcellation}/conf.yaml",
	output:
		"results/{mouse_dates}/{parcellation}/{filter}/filtered_data.h5",
		config = "results/{mouse_dates}/{parcellation}/{filter}/conf.yaml",
	log:
		"results/{mouse_dates}/{parcellation}/{filter}/trial_selection.log"
	conda:
		"envs/environment.yaml"
	resources:
		memb_mb=1000
	script:
		"scripts/trial_selection.py"

def condition_params(wildcards):
	params = {
		"trial_conditions" : { wildcards["cond"] : trial_conditions[wildcards["cond"]]},
		"phase_conditions" : { wildcards["cond"] : phase_conditions[wildcards["cond"]]},
	}
	return params

rule condition:
	'''
	Filters trials into different configured conditions
	'''
	input:
		"results/{mouse_dates}/{parcellation}/{filter}/filtered_data.h5",
		config = "results/{mouse_dates}/{parcellation}/{filter}/conf.yaml",
	output:
		"results/{mouse_dates}/{parcellation}/{filter}/Features/{cond}/conditional_data.h5",
		config = "results/{mouse_dates}/{parcellation}/{filter}/Features/{cond}/conf.yaml",
	params:
		condition_params
	log:
		"results/{mouse_dates}/{parcellation}/{filter}/Features/{cond}/conditionals.log"
	conda:
		"envs/environment.yaml"
	resources:
		memb_mb=1000
	script:
		"scripts/conditional.py"

rule feature_calculation:
	input:
		"results/{mouse_dates}/{parcellation}/{filter}/Features/{cond}/conditional_data.h5",
		config = "results/{mouse_dates}/{parcellation}/{filter}/Features/{cond}/conf.yaml",
	output:
		"results/{mouse_dates}/{parcellation}/{filter}/Features/{cond}/{feature}/feature_data.h5",
		config = "results/{mouse_dates}/{parcellation}/{filter}/Features/{cond}/{feature}/conf.yaml",
	params:
		params = lambda wildcards: features[wildcards["feature"]]
	log:
		"results/{mouse_dates}/{parcellation}/{filter}/Features/{cond}/{feature}/feature_calculation.log"
	conda:
		"envs/environment.yaml"
	resources:
		memb_mb=4000
	script:
		"scripts/feature.py"

rule feature_elimination:
	input:
		feats = [f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/Features/{cond}/{{feature}}/feature_data.h5" for cond in trial_conditions],
		parcellation  = "results/{mouse_dates}/{parcellation}/data.h5",
		#config = "results/{mouse_dates}/{parcellation}/{filter}/{cond}/{feature}/conf.yaml",
	output:
		best_feats = f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/Decoding/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/best_feats.pkl",
		model = f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/Decoding/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/decoder_model.pkl",
		perf = f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/Decoding/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/decoder_perf.pkl",
		config = f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/Decoding/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/conf.yaml",
		plot = f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/Decoding/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/circle_plot.png",
		glassbrain = f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/Decoding/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/glassbrain.html",
	params:
		conds = list(trial_conditions),
		reps = 5, #used to be k_folds but was removed form config
	log:
	   f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/Decoding/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/feature_calculation.log"
	conda:
		 "envs/environment.yaml"
	#resources:
	#	memb_mb=1000
	script:
		  "scripts/recursive_feature_elimination.py"

rule decoding:
	input:
		[f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/Features/{cond}/{{feature}}/feature_data.h5" for cond in trial_conditions],
	output:
		f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/Decoding/decoder/{'.'.join(trial_conditions)}/{{feature}}/{{decoder}}/decoder_model.pkl",
		f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/Decoding/decoder/{'.'.join(trial_conditions)}/{{feature}}/{{decoder}}/decoder_perf.pkl",
		config = f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/Decoding/decoder/{'.'.join(trial_conditions)}/{{feature}}/{{decoder}}/conf.yaml",
	params:
		conds = list(trial_conditions),
		params = lambda wildcards: decoders[wildcards["decoder"]]
	log:
	   f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/Decoding/decoder/{'.'.join(trial_conditions)}/{{feature}}/{{decoder}}/decoding.log",
	conda:
		"envs/environment.yaml"
	resources:
		memb_mb=4000
	script:
		"scripts/decoding.py"



###   Plotting   ###

rule plot_performance:
	input:
		[f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/Decoding/decoder/{'.'.join(trial_conditions)}/{{feature}}/{decoder}/decoder_perf.pkl" for decoder in decoders],
	output:
		f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/Decoding/decoder/{'.'.join(trial_conditions)}/{{feature}}/plots/performance.png",
		f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/Decoding/decoder/{'.'.join(trial_conditions)}/{{feature}}/plots/performance.pkl",
	params:
		conds=list(trial_conditions),
		decoders=decoders,
	log:
		f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/Decoding/decoder/{'.'.join(trial_conditions)}/{{feature}}/plots/plot_performance.log",
	conda:
		 "envs/environment.yaml"
	script:
		  "scripts/plot_performance.py"

rule plot_performances:
	input:
		[f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/Decoding/decoder/{'.'.join(trial_conditions)}/{feature}/{decoder}/decoder_perf.pkl"
				for feature in features
				for decoder in decoders],
	output:
		  f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/Decoding/decoder/{'.'.join(trial_conditions)}/performances.png",
	params:
		conds=list(trial_conditions),
		decoders=decoders,
		features=features,
	log:
		f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/Decoding/decoder/{'.'.join(trial_conditions)}/plot_performances.log",
	conda:
		 "envs/environment.yaml"
	script:
		  "scripts/plot_performances.py"


rule plot_glassbrain:
	input:
		best_feats = f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/Decoding/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/best_feats.pkl",
		parcellation = f"results/{{mouse_dates}}/{{parcellation}}/data.h5",
		feature = f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/Decoding/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/best_feats.pkl",

	output:
		interactive_plot = f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/Decoding/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/glassbrain.html",



rule debug:
	input:
		tasks	= [ f"resources/experiment/{mouse_id}/{date}/task_data/"
					 for mouse_id,dates in mouses.items() for date in dates],
	conda:
		"envs/environment.yaml"
	log:
		"results/debug.log"
	params:
		"?",
		p1 = "Test",
		p2 = 12,
	script:
		"scripts/debug_snakemake.py"



###   legacy tests   ###

rule test_data:
	input:
		 "results/GN06/SVD/data.h5"
	log:
	   "results/GN06/SVD/test_data.log"
	conda:
		 "envs/environment.yaml"
	script:
		  "code/test_data.py"

rule test_analysis:
	input:
		 "results/GN06/SVD/data.h5"
	log:
	   "results/GN06/SVD/test_analysis.log"
	conda:
		 "envs/environment.yaml"
	script:
		  "code/test_analysis.py"
