configfile: "config/config.yaml"

ruleorder: pipeline_entry > parcellation > feature_calculation > feature_elimination


from itertools import product as iterproduct
def create_parameter_product( conf ):
	default_params	= conf["default"] if "default" in conf else {}
	features	= {}
	for feat, params in conf.items():
		if feat == "default":
			continue
		if params is None:
			params	= {}
		# combine params with defaults into total params
		params = default_params | params
		# create a pattern of form "featurename_{}_{}_...", with # of params replacement fields
		pattern	= "_".join( [f"{feat}"] +  ["{}"]*len(params) )
		# insert parameter names and parameter name replacement fields into pattern
		pattern	= pattern.format(*map( "{0}~{{{0}}}".format, params.keys() ))
		# create cartesian product over all parameter values
		values	= iterproduct( *params.values() )
		# create list parameter dictionaries from cartesian product
		values	= [ dict(zip(params.keys(), vals)) for vals in values]
		for vals in values:
			features[ pattern.format(**vals) ] = vals
	return features

mouses 		= config["branch_opts"]["mouses"]
#dates		= config["branch_opts"]["dates"]
#mouse_dates = []

mouse_dates = ["_".join([mouse_id,date]) for mouse_id,dates in mouses.items() for date in dates ]

parcellations	= config["branch_opts"]["parcellations"]
trial_filters		= config["branch_opts"]["selected_trials"]

conditions	= config["branch_opts"]["conditions"]
if conditions is None:
	# if no conditions are given, create cartesian product of all sides and modalities
	sides			= config["trial_conditions"]["sides"]["conds"]
	modalities		= config["trial_conditions"]["modalities"]["conds"]

	trial_conditions	= { f"{side}_{modal}" : {"modality" : m, "target_side_left" : s}
					for side,s in sides.items() for modal,m in modalities.items()}
	phase_condition		= config["phase_conditions"]
	phase_conditions	= dict.fromkeys(trial_conditions.keys(), phase_condition["stimulus"] )
	print(phase_conditions)
else:
	defaults		= conditions["default"] if "default" in conditions else {}

	# create trial_conditions fitting for trial data by resolving column names and conditions from trial_conditions
	trial_condition		= config["trial_conditions"]
	trial_conditions	= { label :
								{
										trial_condition[condition]["column"] : [trial_condition[condition]["conds"][vals] for vals in value] if isinstance(value,list) else trial_condition[condition]["conds"][value]
								for condition, value in (defaults | conds).items() if condition != "phase"}
							for label, conds in conditions.items() if label != "default" }


	# lookup specified phases in phase_conditions
	phase_condition		= config["phase_conditions"]
	phase_conditions	= { label : phase_condition[(defaults | conds)["phase"]] if "phase" in (defaults | conds) else None
					for label, conds in conditions.items() if label != "default" }

feature_conf	= config["branch_opts"]["features"]
features	= create_parameter_product( feature_conf )

rfe_ns		= config["branch_opts"]["rfe"]["selected_features_n"]

decoder_conf	= config["branch_opts"]["decoders"]
decoders	= create_parameter_product( decoder_conf )

wildcard_constraints:
	mouse_dates		= r"[a-zA-Z\d_-]+",
	parcellation	= r"[a-zA-Z\d_]+",
	filter		= r"[a-zA-Z\d_]+",
	cond		= r"[a-zA-Z\d_]+",
	feature		= r"[a-zA-Z\d_~.\[\], ]+",
	decoder		= r"[a-zA-Z\d_~.]+",



###   Output accumulation rules   ###

# The first rule is default
rule all:
	input:
		[ f"results/{'_'.join(mouse_dates)}/{parcellation}/{filter}/decoder/{'.'.join(trial_conditions)}/performances.png"
			for parcellation in parcellations
		  	for filter in trial_filters],
		[ f"results/{'_'.join(mouse_dates)}/{parcellation}/{filter}/decoder/{'.'.join(trial_conditions)}/{feature}/plots/performance.png"
		   	for parcellation in parcellations
		   	for filter in trial_filters
		   	for cond in trial_conditions
		   	for feature in features],
rule all_plots:
	input:
		 [ f"results/{'_'.join(mouse_dates)}/{parcellation}/{filter}/decoder/{'.'.join(trial_conditions)}/{feature}/plots/performance.png"
			   for parcellation in parcellations
			   for filter in trial_filters
			   for cond in trial_conditions
			   for feature in features]

rule all_decode:
	input:
		[ f"results/{'_'.join(mouse_dates)}/{parcellation}/{filter}/decoder/{'.'.join(trial_conditions)}/{feature}/{decoder}/decoder_model.pkl"
				for parcellation in parcellations
				for filter in trial_filters
				for feature in features
				for decoder in decoders]

rule all_features:
	input:
		[ f"results/{'_'.join(mouse_dates)}/{parcellation}/{filter}/{cond}/{feature}/feature_data.h5"
				for parcellation in parcellations
				for filter in trial_filters
				for cond in trial_conditions
				for feature in features ]

rule all_rfe:
	input:
		 [ f"results/{'_'.join(mouse_dates)}/{parcellation}/{filter}/rfe/{'.'.join(trial_conditions)}/{rfe_n}/{feature}/circle_plot.png"
		   for parcellation in parcellations
		   for filter in trial_filters
		   for feature in features
		   for rfe_n in rfe_ns]



###   Data processing   ###

rule pipeline_entry:
	input:
		_	= [[ f"resources/experiment/{mouse_id}/{date}/task_data/"
					 for date in dates] for mouse_id,dates in mouses.items()], #To make sure that files are present, unfortunatly gets flattened -> losing information which dates belong to which mouse
		Vc	= [ f"resources/experiment/{mouse_id}/{date}/SVD_data/Vc.mat"
				  for mouse_id,dates in mouses.items() for date in dates],
		trans_params = [ f"resources/experiment/{mouse_id}/{date}/SVD_data/opts.mat"
						 for mouse_id,dates in mouses.items() for date in dates],
	output:
		"results/{mouse_dates}/SVD/data.h5",
		config = "results/{mouse_dates}/SVD/conf.yaml",
	params:
		mouse_dates_str = '_'.join(mouse_dates),
		#maybe find a clean solution from flattened array,
		task_structured = {mouse_id: [ f"resources/experiment/{mouse_id}/{date}/task_data/"
				  for date in dates] for mouse_id,dates in mouses.items()} # so we are using this one and we can actually use a dict to make it even comfier
	log:
		"results/{mouse_dates}/SVD/pipeline_entry.log"
	conda:
		"envs/environment.yaml"
	resources:
		memb_mb=1000
	script:
		"scripts/default_entry.py"

def parcellation_input(wildcards):
	input = {
		"data"	: "results/{mouse_dates}/SVD/data.h5",
		"config": "results/{mouse_dates}/SVD/conf.yaml" }
	#if wildcards["parcellation"] in config["parcellation_opts"]["paths"].keys(): <- leads to such a weird error
	if wildcards["parcellation"]!='ICA':
		input["meta"]	= config["parcellation_opts"]["paths"][wildcards["parcellation"]]
	return input

rule parcellation:
	input:
		unpack(parcellation_input)
	output:
		"results/{mouse_dates}/{parcellation}/data.h5",
		config = "results/{mouse_dates}/{parcellation}/conf.yaml",
	wildcard_constraints:
		parcellation = "(?!SVD).+"
	log:
		"results/{mouse_dates}/{parcellation}/parcellation.log"
	conda:
		"envs/environment.yaml"
	script:
		"scripts/parcellation.py"

rule trial_selection:
	input:
		"results/{mouse_dates}/{parcellation}/data.h5",
		config = "results/{mouse_dates}/{parcellation}/conf.yaml",
	output:
		"results/{mouse_dates}/{parcellation}/{filter}/filtered_data.h5",
		config = "results/{mouse_dates}/{parcellation}/{filter}/conf.yaml",
	log:
		"results/{mouse_dates}/{parcellation}/{filter}/trial_selection.log"
	conda:
		"envs/environment.yaml"
	resources:
		memb_mb=1000
	script:
		"scripts/trial_selection.py"

def condition_params(wildcards):
	params = {
		"trial_conditions" : { wildcards["cond"] : trial_conditions[wildcards["cond"]]},
		"phase_conditions" : { wildcards["cond"] : phase_conditions[wildcards["cond"]]},
	}
	return params

rule condition:
	input:
		"results/{mouse_dates}/{parcellation}/{filter}/filtered_data.h5",
		config = "results/{mouse_dates}/{parcellation}/{filter}/conf.yaml",
	output:
		"results/{mouse_dates}/{parcellation}/{filter}/{cond}/conditional_data.h5",
		config = "results/{mouse_dates}/{parcellation}/{filter}/{cond}/conf.yaml",
	params:
		condition_params
	log:
		"results/{mouse_dates}/{parcellation}/{filter}/{cond}/conditionals.log"
	conda:
		"envs/environment.yaml"
	resources:
		memb_mb=1000
	script:
		"scripts/conditional.py"

rule feature_calculation:
	input:
		"results/{mouse_dates}/{parcellation}/{filter}/{cond}/conditional_data.h5",
		config = "results/{mouse_dates}/{parcellation}/{filter}/{cond}/conf.yaml",
	output:
		"results/{mouse_dates}/{parcellation}/{filter}/{cond}/{feature}/feature_data.h5",
		config = "results/{mouse_dates}/{parcellation}/{filter}/{cond}/{feature}/conf.yaml",
	params:
		params = lambda wildcards: features[wildcards["feature"]]
	log:
		"results/{mouse_dates}/{parcellation}/{filter}/{cond}/{feature}/feature_calculation.log"
	conda:
		"envs/environment.yaml"
	resources:
		memb_mb=4000
	script:
		"scripts/feature.py"

rule feature_elimination:
	input:
		feats = [f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/{cond}/{{feature}}/feature_data.h5" for cond in trial_conditions],
		parcellation  = "results/{mouse_dates}/{parcellation}/data.h5",
		#config = "results/{mouse_dates}/{parcellation}/{filter}/{cond}/{feature}/conf.yaml",
	output:
		best_feats = f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/best_feats.pkl",
		model = f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/decoder_model.pkl",
		perf = f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/decoder_perf.pkl",
		config = f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/conf.yaml",
		plot = f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/circle_plot.png",
		glassbrain = f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/glassbrain.html",
	params:
		conds = list(trial_conditions),
		reps = 5, #used to be k_folds but was removed form config
	log:
	   f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/feature_calculation.log"
	conda:
		 "envs/environment.yaml"
	resources:
		memb_mb=1000
	script:
		  "scripts/recursive_feature_elimination.py"

rule decoding:
	input:
		[f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/{cond}/{{feature}}/feature_data.h5" for cond in trial_conditions],
	output:
		f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/decoder/{'.'.join(trial_conditions)}/{{feature}}/{{decoder}}/decoder_model.pkl",
		f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/decoder/{'.'.join(trial_conditions)}/{{feature}}/{{decoder}}/decoder_perf.pkl",
		config = f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/decoder/{'.'.join(trial_conditions)}/{{feature}}/{{decoder}}/{'.'.join(trial_conditions)}/conf.yaml",
	params:
		conds = list(trial_conditions),
		params = lambda wildcards: decoders[wildcards["decoder"]]
	log:
	   f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/decoder/{'.'.join(trial_conditions)}/{{feature}}/{{decoder}}/decoding.log",
	conda:
		"envs/environment.yaml"
	resources:
		memb_mb=4000
	script:
		"scripts/decoding.py"



###   Plotting   ###

rule plot_performance:
	input:
		[f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/decoder/{'.'.join(trial_conditions)}/{{feature}}/{decoder}/decoder_perf.pkl" for decoder in decoders],
	output:
		f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/decoder/{'.'.join(trial_conditions)}/{{feature}}/plots/performance.png",
		f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/decoder/{'.'.join(trial_conditions)}/{{feature}}/plots/performance.pkl",
	params:
		conds=list(trial_conditions),
		decoders=decoders,
	log:
		f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/decoder/{'.'.join(trial_conditions)}/{{feature}}/plots/plot_performance.log",
	conda:
		 "envs/environment.yaml"
	script:
		  "scripts/plot_performance.py"

rule plot_performances:
	input:
		[f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/decoder/{'.'.join(trial_conditions)}/{feature}/{decoder}/decoder_perf.pkl"
				for feature in features
				for decoder in decoders],
	output:
		  f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/decoder/{'.'.join(trial_conditions)}/performances.png",
	params:
		conds=list(trial_conditions),
		decoders=decoders,
		features=features,
	log:
		f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/decoder/{'.'.join(trial_conditions)}/plot_performances.log",
	conda:
		 "envs/environment.yaml"
	script:
		  "scripts/plot_performances.py"


rule plot_glassbrain:
	input:
		best_feats = f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/best_feats.pkl",
		parcellation = f"results/{{mouse_dates}}/{{parcellation}}/data.h5",
		feature = f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/best_feats.pkl",

	output:
		interactive_plot = f"results/{{mouse_dates}}/{{parcellation}}/{{filter}}/rfe/{'.'.join(trial_conditions)}/{{rfe_n}}/{{feature}}/glassbrain.html",



rule debug:
	input:
		tasks	= [ f"resources/experiment/{mouse_id}/{date}/task_data/"
					 for mouse_id,dates in mouses.items() for date in dates],
	conda:
		"envs/environment.yaml"
	log:
		"results/debug.log"
	script:
		"scripts/debug_snakemake.py"



###   legacy tests   ###

rule test_data:
	input:
		 "results/GN06/SVD/data.h5"
	log:
	   "results/GN06/SVD/test_data.log"
	conda:
		 "envs/environment.yaml"
	script:
		  "code/test_data.py"

rule test_analysis:
	input:
		 "results/GN06/SVD/data.h5"
	log:
	   "results/GN06/SVD/test_analysis.log"
	conda:
		 "envs/environment.yaml"
	script:
		  "code/test_analysis.py"
